#include <iostream>
using namespace std;

// 분할정복 - 정의
// 분할정복 (Divide and Conquer)
// - 하나의 큰 문제를 작은 문제로 분할하여 문제를 해결하는 방법
// - 문제를 둘 이상의 부분문제로 "나눈" 뒤 (Divide)
// - 각 문제에 대한 답을 "계산"하고 (Conquer)
// - 원래 문제에 대한 답으로 "병합" (Merge)
// - 병합횟수 : logN
// -> 병합할 때 O(M)이면, 총 시간복잡도 O(MlogN)

// 분할정복 vs DP
// 공통점
// - 큰 문제를 작은 문제 여러 개로 나눠서 해결
// 차이점
// - DnC : 중복되는 부분 문제 없이 완벽하게 분할
// - DP : 중복되는 부분 문제 발생
// -> 메모이제이션으로 해결

// 분할정복 - 구조
// - 재귀적으로 자신을 호출하면서 연산의 단위를 조금씩 줄여가는 구조
// - "F(x)가 간단" 조건을 만족할 때까지 문제를 쪼개서 답을 구하는 방식
/*
int F(x) {
	// Conquer
	if (F(x)의 문제가 간단) {
		return F(x)를 직접 계산한 값;
	}

	// Divide
	x를 y1, y2로 분할;
	F(y1)과 F(y2)를 호출;

	// Merge
	return F(y1), F(y2)로부터 F(x)를 구한 값;
}
*/

// 분할정복 - 장단점
// 장점
// - 문제를 나눔으로써 어려운 문제 해결 가능
// - 병렬적으로 문제 해결
// -> 시간 단축
// 단점
// - 함수를 재귀적으로 호출
// - 과도한 메모리 사용

// 분할정복 정리
// 분할정복 (Divide and Conquer)
// - Divide -> Conquer -> Merge
// - 중복되는 부분 문제 X (DP와의 차이점)
// - Merge 횟수 : logN
// - "F(x)가 간단"해질 때까지 쪼개어 재귀 호출



// 완전탐색 - 정의
// 완전탐색이란 ? (exhaustive search)
// - 모든 경우의 수를 찾아서 답을 찾는 방법
// - 가장 확실한 방법이지만 가장 시간이 오래 걸리는 기법
// - 입력(N) 제한이 작다면 완전탐색인지 의심해보자

// 완전탐색 - 종류
// 1. 브루트포스 : 반복 / 조건문을 활용해 모두 테스트하는 방법
// 2. 비트마스크 : 2진수 표현 기법을 활용하는 방법
// 3. 재귀 : 자기 자신을 호출하여 작업을 반복 수행하는 방법
// 4. 순열 : n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법
// 5. DFS, BFS : 그래프에서 모든 정점을 탐색하는 방법

// 완전탐색 - 재귀
// - 재귀함수를 이용해서 문제 조건을 만족하는 경우들 생성
// 재귀함수 : 자기 자신을 호출하는 함수
// - 단순히 호출하지 않음
// -> 마지막인지 어떻게 확인할 수 있을까?

// 완전탐색 - 재귀함수
// 재귀함수
// - 기본 구성
// 1. 공통 작업 (선택)
// 2. 종료 조건 ( = 기저 사례)
// 3. 현재 단계에서 수행할 작업
// 4. 다음 단계 (점화식)



// 종이의 각 칸에는 -1, 0, 1 중 하나가 저장되어 있다.
int cnt_1 = 0, cnt0 = 0, cnt1 = 0;
// N×N크기의 행렬로 표현되는 종이가 있다.
// (1 ≤ N ≤ 3^7, N은 3^k 꼴)
// 3^7 = 2187
int matrix[2200][2200];

// Divide : 문제를 둘 이상의 부분문제로 나눈 뒤
// 재귀 - 현재 단계에서 수행할 작업
bool issame(int y, int x, int n) {
	// matrix[행 번호][열 번호]
	int num = matrix[y][x];

	for (int i = y; i < y + n; i++) {
		for (int j = x; j < x + n; j++) {
			if (num != matrix[i][j]) {
				return false;
			}
		}
	}

	// 1. 만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.
	return true;
}

// 이와 같이 종이를 잘랐을 때,
// -1로만 채워진 종이의 개수,
// 0으로만 채워진 종이의 개수, 
// 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.
void div(int y, int x, int n) {
	// 1. 만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.
	// Merge : 원래 문제에 대한 답으로 병합
	// 재귀 - 종료 조건 ( = 기저 사례)
	if (issame(y, x, n)) {
		if (matrix[y][x] == -1) {
			cnt_1++;
		}
		else if (matrix[y][x] == 0) {
			cnt0++;
		}
		else if (matrix[y][x] == 1) {
			cnt1++;
		}
	}
	// Conquer : 각 문제에 대한 답을 계산하고
	// 재귀 - 다음 단계 (점화식)
	else {
		// 2. (1)이 아닌 경우에는 종이를 같은 크기의 종이 9개로 자르고,
		int cut = n / 3;

		// 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				div(cut * i + y, cut * j + x, cut);
			}
		}
	}
}

int main() {
	int n;

	// N x N 크기의 행렬로 표현되는 종이가 있다.
	// 첫째 줄에 N이 주어진다. 
	cin >> n;

	// 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> matrix[i][j];
		}
	}

	// 우리는 이 행렬을 다음과 같은 규칙에 따라 적절한 크기로 자르려고 한다.
	div(0, 0, n);

	// 첫째 줄에 - 1로만 채워진 종이의 개수를,
	// 둘째 줄에 0으로만 채워진 종이의 개수를,
	// 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.
	cout << cnt_1 << '\n' << cnt0 << '\n' << cnt1;

	return 0;
}