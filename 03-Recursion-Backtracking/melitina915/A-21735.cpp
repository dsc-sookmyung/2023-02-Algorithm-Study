#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
// using namespace std에 size, time이 선언되어있음
// 변수 이름을 size, time 외에 다른 것을 사용



// 완전탐색 - 정의
// 완전탐색이란? exhaustive search
// - 모든 경우의 수를 찾아서 답을 찾는 방법
// - 가장 확실한 방법이지만 가장 시간이 오래 걸리는 기법
// - 입력(N) 제한이 작다면 완전탐색인지 의심해보자

// 완전탐색 - 종류
// 1. 브루트포스
// - 반복/조건문을 활용해 모두 테스트하는 방법
// 2. 비트마스크
// - 2진수 표현 기법을 활용하는 방법
// 3. 재귀
// - 자기 자신을 호출하여 작업을 반복 수행하는 방법
// 4. 순열
// - n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법
// 5. DFS, BFS
// - 그래프에서 모든 정점을 탐색하는 방법

// 완전탐색 - 브루트포스
// - Brute force : 무식한 힘
// - 단순히 for문과 if문 등으로 모든 경우들을 만들어 답을 구함

// 완전탐색 - 비트마스크
// - 2진수 이용
// - 모든 경우의 수가 1 또는 0으로 구성되는 경우

// 완전탐색 - 재귀
// - 재귀함수 : 자기 자신을 호출하는 함수
// - 단순히 호출하지 않음
// -> 마지막인지 어떻게 확인할 수 있을까?
// - 재귀함수를 이용해서 문제 조건을 만족하는 경우들 생성

// 완전탐색 - 재귀함수
// - 기본 구성
// 1. 공통 작업 (선택)
// 2. 종료 조건 ( = 기저 사례)
// 3. 현재 단계에서 수행할 작업
// 4. 다음 단계 (점화식)

// 완전탐색 - 순열
// - 순열 : 서로 다른 N개를 일렬로 나열하는 모든 경우의 수
// -> 시간복잡도 : O(N!) (N이 정말 작을 때만 사용 가능)
// - 순열에 원소를 하나씩 채워가는 방식
// 1) 단순 중첩 for문으로 구현 가능
// 2) 재귀함수로 깔끔하게
// 3) C++의 next_permutation
// * 주의사항
// 1) 미리 오름차순 정렬
// 2) 오름차순으로 순열 생성
// vector <int> v;
// v.push_back(i)
// next_permutation(v.begin(), v.end())

// 완전탐색 - DFS, BFS
// - 모든 곳을 다 방문한다는 점에서 완전탐색으로 분류 가능
// - DFS : 깊이 우선 탐색 (Depth First Search)
// - BFS : 너비 우선 탐색 (Breadth First Search)

// 완전탐색 - 정리
// 완전탐색이란?
// - 모든 경우의 수를 찾아서 답을 찾는 방법
// 종류
// - 브루트포스 : 반복/조건문
// - 비트마스크 : 2진수 표현 기법
// - 재귀 : 자기 자신을 호출 (종료조건&점화식)
// - 순열 : 원소 줄세우기
// - DFS, BFS : 그래프에서 모든 정점 탐색



// 백트래킹 - 정의
// 백트래킹이란? backtracking
// - 한정된 조건을 가진 문제를 풀려는 전략
// - 가지치기(Pruning)
// - 시간이 오래 걸린다는 완전탐색의 단점 보완
// - 간단한 백트래킹 문제는 기본 구성에서 크게 벗어나지 X

// 백트래킹 - 구조
// - 주로 재귀함수로 구현
// 1. 종료 조건
// 2. 반복문
// 3. 제한 조건
// 4. 상태 변화
// 5. 다음 단계
// 6. 원상 복구

// 완전탐색 vs 백트래킹
// 완전탐색
// - 가능한 모든 경우의 수 탐색
// - 시간이 오래 걸림
// - 브루트포스, DFS/BFS
// 백트래킹
// - 가지치기를 통해 조건에 어긋나는 경우는 탐색 X
// - 완전탐색보다 시간 단축 (제한 조건 많을수록 더 많이 단축)
// - 주로 재귀함수로 구현
// 문제풀이 tip
// - 일단 완전탐색으로 풀었을 때의 시간복잡도 계산
// -> 가능할 것 같으면 한 번 풀어보고
// -> 시간초과 날 것 같으면 백트래킹 시도






// 앞마당의 길이는 N이고 위치 1부터 위치 N까지만 눈이 쌓여있다.
// 대회 규칙은 해당 앞마당에서 M초 동안 눈덩이를 굴려 눈사람을 만드는 것이다.
// 눈덩이의 시작 크기는 1이다.
int n, m, sec = 0, snow = 1, snowball = 0;
// 위치 i에 눈이 a_i만큼 쌓여있다.
int a[101];



// 백트래킹
// - 한정된 조건을 가진 문제를 풀려는 전략
// - 가지치기(Pruning)
// - 가지치기를 통해 조건에 어긋나는 경우는 탐색 X
// - 시간이 오래 걸린다는 완전탐색의 단점 보완
// - 완전탐색보다 시간 단축 (제한 조건 많을수록 더 많이 단축)
// - 간단한 백트래킹 문제는 기본 구성에서 크게 벗어나지 X
// - 주로 재귀함수로 구현
void backtrack(int idx, int snow, int sec) {
	// 1. 종료 조건
	// 3. 제한 조건
	
	// 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 구하는 프로그램을 작성해보자.
	if (sec >= m) {
		snowball = max(snowball, snow);

		return;
	}
	
	// - 주로 재귀함수로 구현
	// 4. 상태 변화
	// 5. 다음 단계

	// 눈덩이를 굴리는 방법에는 두 가지가 있다. 
	// 눈덩이를 굴리거나 던질 때 1초가 소모된다.
	// 눈덩이가 앞마당의 끝에 도달한 경우 남은 시간과 관계없이 눈덩이 굴리기는 끝이 난다.
	// 1. 눈덩이를 현재 위치 +1칸으로 굴린다.
	// 현재 칸의 위치를 i라고 하면 눈덩이의 크기는 a_{ i + 1 } 만큼 늘어난다.
	backtrack(idx + 1, snow + a[idx + 1], sec + 1);
	// 2. 눈덩이를 현재 위치 +2칸으로 던진다.
	// 눈덩이가 착지하며 충격을 받아 눈덩이의 크기는 원래의 크기의 반으로 줄어들고
	// 현재 칸의 위치를 i라고 하면 눈덩이의 크기는 a_{ i + 2 } 만큼 늘어난다.
	// 이 때 소수점은 절사한다.
	// 눈덩이를 던져 크기가 0이 되어도 눈덩이는 사라지지 않는다.
	backtrack(idx + 2, snow / 2 + a[idx + 2], sec + 1);
}

int main() {
	// 첫째 줄에 공백을 기준으로 앞마당의 길이 N (1 <= N <= 100),
	// 대회의 시간 M (1 <= M <= 10)이 주어진다.
	cin >> n >> m;
	
	// 둘째 줄에 길이가 N인 수열 a가 주어진다. (1 <= a_i <= 1,000,000)
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	// 눈덩이의 시작 위치는 0이다.
	backtrack(0, snow, sec);

	// 첫째 줄에 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 출력한다.
	cout << snowball;

	return 0;
}