#include <iostream>
#include <cmath>
using namespace std;

// 실제 데이터와 데이터를 표현하는 형식은 별개의 것이므로,
// 이 둘을 분리하면 좋다. 
// 이렇게 역할에 맞게 분리하는 습관은 결국 정답이다.
// 설계가 코딩에 앞선다

// 데이터를 표현하는 형식
// 제일 밑의 원판을 3번 기둥으로 옮기는 작업
void move(int from, int to)
{
	// 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데,
	// 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.
	cout << from << " " << to << '\n';
}

// 실제 데이터
// hanoi(N, start, to, via):
// start에서 to로 via를 거쳐 총 N개의 원반을 운반할 때 각 이동 과정을 출력하라
void Hanoi(int n, int start, int tmp, int end) {
	if (n == 1) {
		move(start, end);
	}
	else {
		// n-1개의 원판을 1번 기둥에서 3번 기둥을 거쳐 2번 기둥으로 옮긴다
		// start(1번 기둥)에서 end(3번 기둥)를 거쳐 tmp(2번 기둥)로 옮기는 것
		Hanoi(n - 1, start, end, tmp);

		// 제일 밑의 하나 남은 원판을 3번 기둥으로 옮기는 작업
		move(start, end);

		// 옮겼던 n-1개의 원판을 2번 기둥에서 1번 기둥을 거쳐 3번 기둥으로 옮긴다
		// tmp(2번 기둥)에서 start(1번 기둥)를 거쳐 end(3번 기둥)로 옮기는 것
		Hanoi(n - 1, tmp, start, end);
	}
}

int main() {
	int n;

	// 첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.
	cin >> n;
	
	// A(n) = 2 * A(n - 1) + 1
	// 양변에 + 1
	// A(n) + 1 = 2 * A(n - 1) + 2
	// A(n) + 1 = 2 * (A(n - 1) + 1)
	// B(n) = 2 * B(n - 1)
	// -> 공비가 2인 등비수열
	// 등비수열의 합 공식 : (2^n - 1) / (2 - 1) = 2^n - 1
	
	// 1 << n 은 2^n 을 표현한 시프트 연산
	// 하노이 탑 최소 이동 횟수 : 2^n - 1
	// 첫째 줄에 옮긴 횟수 K를 출력한다.
	// 단, 이동 횟수는 최소가 되어야 한다.
	cout << (1 << n) - 1 << '\n';

	// 이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라.
	// 두 번째 줄부터 수행 과정을 출력한다. 
	Hanoi(n, 1, 2, 3);

	return 0;
}