#include <iostream>
#include <string>
#include <vector>
using namespace std;

int map[10][10];
vector<pair<int, int>> empties;

// 스도쿠 출력
void printNumber() {
    // 9개의 줄에 9개의 숫자로 답을 출력한다. 
    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= 9; j++) {
            cout << map[i][j];
        }

        cout << '\n';
    }
}

// 스도쿠 중복 체크
bool isPossible(int x, int y, int k) {
    // map[행 번호 x][열 번호 y]

    for (int i = 1; i <= 9; i++) {
        // 각 행에 1부터 9까지의 숫자가 중복 없이 나오고,
        // (k와 숫자가 동일하며 같은 줄(열)에 있지 않을 경우)
        // 1. i 행에 있는 모든 수
        if (map[x][i] == k && i != y) {
            return false;
        }
        
        // 각 열에 1부터 9까지의 숫자가 중복 없이 나오고, 
        // (k와 숫자가 동일하며 같은 줄(행)에 있지 않을 경우)
        // 2. j열에 있는 모든 수
        if (map[i][y] == k && i != x) {
            return false;
        }
        
        // 각 3×3짜리 사각형(9개이며, 위에서 색깔로 표시되었다)에
        // 1부터 9까지의 숫자가 중복 없이 나오기 때문이다.
        int nx = (x - 1) / 3 * 3 + 1 + (i - 1) / 3;
        int ny = (y - 1) / 3 * 3 + 1 + (i - 1) % 3;
        // (k와 숫자가 동일하며 탐색 중인 (nx, ny)가 (x, y) 위치와 다를 경우)
        // 3. (i, j)가 속해있는 사각형 그룹에 속해있는 모든 수
        if (map[nx][ny] == k && !(nx == x && ny == y)) {
            return false;
        }
    }

    return true;
}

// 백트래킹 함수
void backTracking(int idx) {
    // 4. 재귀함수의 끝까지 갔을 때(빈칸을 다 탐색한 경우),
    // 모든 빈칸이 메꿔진 상태이므로 스도쿠가 성공한 것이다. 
    // 빈칸을 다 채웠다면
    if (idx == empties.size()) {
        // 그러므로 맵을 출력 한다.
        // 완성된 스도쿠를 출력하고
        printNumber();
        // 프로그램을 끝낸다
        exit(0);
    }

    int x = empties[idx].first;
    int y = empties[idx].second;

    // 1. 빈칸의 위치정보를 담은 배열에서 가장 앞에 있는 위치를 가져온다.
    for (int k = 1; k <= 9; k++) {
        // 2. 그 위치에 1에서부터 9까지 중에,
        // 위 3가지와 겹치지 않는 수(가능한 수)가 있으면
        // 숫자 k가 채워져도 될 경우
        if (isPossible(x, y, k)) {
            // 빈칸을 해당 수로 채우고 다음 빈칸 위치로 이동한다.
            // map[i][j] = i행 j열에 들어갈 수 있는 수
            map[x][y] = k;

            // 3. 2번과 같은 행동을 가능한 수가 하나라도 존재하지 않거나,
            // 맵의 끝까지 탐색할 때까지 반복한다(재귀함수 호출).
            // 다음 위치(idx)로 옮겨 탐색
            // 어떤 수가 맞는지 확인해 보려면 그 수를 넣어보고 다른 수들을 끝까지 채워보는 수밖에 없다. 
            // 그렇게 진행하다가 빈칸을 채울 수 없는 경우가 생기면,
            // 그 수를 넣는 것이 틀렸다는 것을 알 수 있을 것이다.
            // 해당 값이 맞는지 확인하기 위해 들어갈 수 있는 값을 하나씩 넣어서 끝까지 진행하여 확인해 보는 수밖에 없다.
            // 결국 수를 넣는 것을 반복하면서 결과를 확인하고 틀렸다면,
            // 다시 돌아가서 다시 다른 수를 넣어보는 것이다.
            backTracking(idx + 1);
            // 가능한 수가 없어 종료되면,
            // 해당 함수를 호출한 함수로 돌아가 그다음 가능한 수로 다시 한번 2번 행위를 반복한다.
            
            // 다른 수도 사용할 수 있도록 할당 해제
            map[x][y] = 0;
        }
    }
}

int main() {
    // 9개의 줄에 9개의 숫자로 보드가 입력된다. 
    for (int i = 1; i <= 9; i++) {
        string str;

        cin >> str;
        
        for (int j = 1; j <= 9; j++) {
            map[i][j] = str[j - 1] - '0';
            
            // 아직 숫자가 채워지지 않은 칸에는 0이 주어진다.
            if (map[i][j] == 0) {
                empties.push_back(make_pair(i, j));
            }
        }
    }

    // 하다 만 스도쿠 퍼즐이 주어졌을 때,
    // 마저 끝내는 프로그램을 작성하시오.
    backTracking(0);
}