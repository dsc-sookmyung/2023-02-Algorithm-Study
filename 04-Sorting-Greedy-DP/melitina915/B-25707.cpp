#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdlib>
using namespace std;

// 그리디 알고리즘 - 정의
// - What?
// 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법
// -> 모든 선택지를 고려하지 않고, 각 단계마다 지금 가장 좋은(탐욕적인) 방법만을 선택
// -> 탐색범위가 줄어서 빠른 시간에 해결 가능(시간 복잡도 감소)
// ex) merge 함수
/*
void merge(int arr[], int l, int m, int r) {
	// 각각 arr의 왼쪽, arr의 중간, tmp의 왼쪽
	int idx1, idx2, idx3;
	idx1 = idx3 = l;
	idx2 = m;

	while (idx1 < m && idx2 < r) {
		if (arr[idx1] < arr[idx2]) {
			tmp[idx3++] = arr[idx1++];
		}
		else {
			tmp[idx3++] = arr[idx2++];
		}
	}

	while (idx1 < m) {
		tmp[idx3++] = arr[idx1++];
	}
	while (idx2 < r) {
		tmp[idx3++] = arr[idx2++];
	}

	for (int i = l; i < r; i++) {
		arr[i] = tmp[i];
	}
}
*/
// -> 그리디 알고리즘은 항상 성립할까?
// - 현재의 선택이 앞으로 남은 선택에 어떤 영향을 끼칠지는 고려하지 않음.
// - 순간 최적 선택한 결과가 전체 문제의 최적이라는 보장이 없음.

// 그리디 알고리즘 - 정당성 증명
// - When?
// 1. 탐욕적 선택 속성 (greedy choice property)
// 앞의 선택이 이후의 선택에 영향을 주지 않는 경우
// ( = 탐욕적으로만 선택하더라도 최적해를 구할 수 있는 경우)
// 2. 최적 부분 구조 (optimal substructure)
// 전체 문제의 최적해가 각 부분 문제들의 최적해로 이루어진 경우

// 그리디 알고리즘 - 동적 계획법과 비교
// 공통점
// - 최적 부분 구조를 가짐
// 차이점
// - DP
// 부분 최적해를 구할 때 탐색 범위를 줄이지 않음 (다만 중복 문제는 메모이제이션)
// 항상 최적해를 보장함
// - Greedy
// 부분 최적해를 구할 때 탐색 범위를 줄여서 탐욕적으로 선택함
// 항상 최적해를 보장하지는 않음 (정당성 증명 과정 필요)
// 대개 동적 계획법보다 더 빠름

// 그리디 알고리즘 - 문제 해결 과정
// - How?
// 1. 전체 문제를 작은 부분 문제로 나누기
// 2. 부분의 최적해를 찾기
// 3. 부분 최적해가 정당한지 증명하기
// 4. 구현하기

// 그리디 알고리즘 - 장단점
// - 단점
// 부분 최적해를 떠올리는 것은 직관에 의존함
// 부분 최적해의 정당성을 증명해야 함
// - 장점
// 특정 상황에서 DP보다 빠른 속도로 최적해를 도출함

// 그리디 알고리즘 - 사소한 Tip
// 매번 증명해야 하나요?
// - 코딩테스트에서는 직관을 믿고 일단 풀자
// 확신이 없다면 다른 문제 먼저 풀기
// - 평소에는 증명 연습을 하자
// 생각하는 힘 기르기
// 
// 그리디 문제를 어떻게 대할까?
// - 문제의 상황이 그리디 알고리즘에 적합한 지 살피기
// - 어떠한 기준으로 정렬해서 그 순서대로 처리하면 이득이 되는 지 생각해보기
// - 직관 혹은 증명을 통해 어떤 기준이 확실하다면 구현하기
// - 만약 그 기준이 보이지 않는다면 DP 등 다른 풀이를 생각해보기
// - 많은 유형을 접해보며 그리디를 떠올리는 연습하기



int main() {
	// 3 ≤ N ≤ 1,000
	int n, len = 0;
	vector<int> marble;

	// 오늘의 활동은 구슬 N개를 줄로 이어 팔찌를 만드는 것이다. 
	// 첫 번째 줄에 구슬의 개수 N이 주어진다.
	cin >> n;

	// 두 번째 줄에 각 구슬에 적힌 수 N개가 공백으로 구분되어 차례로 주어진다.
	for (int i = 0; i < n; i++) {
		// 1 ≤ 구슬에 적힌 수 ≤ 10^9
		// 각 구슬에는 서로 다른 수가 하나씩 적혀 있는데,
		// 각 구슬에 적힌 수는 모두 다르다.
		int num;

		cin >> num;
		
		marble.push_back(num);
	}

	// N개의 구슬로 팔찌를 만들되 줄을 가능한 적게 사용할 것을 부탁하였다.
	// 숫자 사이의 거리 값의 합이 최소가 되게 하는 가장 쉬운 방법은
	// 순차적으로 배치를 하는 것이다.
	sort(marble.begin(), marble.end());

	// 두 구슬 사이를 잇는 줄의 길이는
	// 두 구슬에 적힌 수들의 차의 절댓값이 되어야 한다.
	for (int i = 1; i < n; i++) {
		len += abs(marble[i] - marble[i - 1]);
	}

	len += abs(marble[0] - marble[n - 1]);

	// N개의 구슬을 모두 사용하여 조건에 맞게 팔찌를 만들 때 사용하는 줄의 길이의 최솟값을 출력한다.
	cout << len;

	return 0;
}