#include <iostream>
using namespace std;

// Dynamic Programming

// 학습 목표
// 1. 동적 계획법을 사용하는 이유와 사용하기위한 조건을 안다.
// 2. DP 문제를 읽고 초기 상태를 파악하고 점화식을 세울 수 있다.

// 동적 계획법 - 정의
// 동적 계획법 (Dynamic Programming)
// - 하나의 큰 문제를 여러 개의 작은 문제로 나누어서
// 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용
// 1. 큰 문제를 작은 문제로 쪼갠다
// F(n) -> F(n - 1) F(n - 2)
// 2. 그 답을 저장해두고 재활용한다
// -> 이미 구한 피보나치 수는 따로 저장

// 동적 계획법 - 사용하는 이유
// F(n) = F(n - 1) + F(n - 2)
// 단순히 재귀함수 사용하면 동일한 작은 문제들이 반복됨
// -> 반복되는 문제들의 결과값을 미리 저장하자 !!

// 사용 조건 - 최적 부분 구조
// 최적 부분 구조 (Optimal Substructure)
// - 부분 문제의 최적 결과값 -> 전체 문제의 최적 결과
// ex) A -> B까지의 가장 짧은 경로 찾기
// - A -> X / X -> B가 가장 짧은 경로라면
// - 전체 최적 경로도 A -> X -> B

// 사용 조건 - 중복되는 부분 문제
// 중복되는 부분 문제 (Overlapping Subproblems)
// - 동일한 작은 문제들이 반복하여 나타나는 경우
// - 부분 문제가 반복적으로 나타나지 않으면 재사용 불가능
// - 시간복잡도 대폭 감소

// 문제 해결 과정
// 1. DP로 풀 수 있는 문제인지 점검
// 두 가지 사용 조건들이 충족되는지 확인
// - 최적 부분 구조, 중복되는 부분 문제
// 주로 사용하는 경우
// - 특정 데이터 내 최댓값/최솟값 계산
// - 특정 조건 내 데이터 셀 때
// + 도형, 수학
// 
// 2. 문제의 변수 파악
// 문제 내 변수(state) 결정
// - 피보나치 수열 : n
// 주로 문제에서 구해야하는 값을 보고 결정
// * 변수란?
// - 결과값을 바뀌게 만들어주는 수
// - 매개변수의 개념
// 
// 3. 변수 간 관계식 만들기
// 현재 변수값과 이전 / 다음 변수값과의 관계식
// - 피보나치 수열 : F(n) = F(n - 1) + F(n - 2)
// - 변수의 개수가 2개 이상이면 관계식도 복잡해질 수 있음
// 관계식이 있어야 반복 or 재귀를 통해 문제 해결 가능
// 
// 4. 메모하기
// memoization / tabulation
// 변수값에 따른 결과 저장
// 결과를 저장할 배열 생성
// - 결과가 나올 때마다 배열 내에 저장
// - 저장된 값 재사용
// - 변수의 개수에 따라 배열 차원이 1 ~ 3차원
// 
// 5. 기저 상태 파악하기
// 가장 작은 문제의 상태 파악
// - 피보나치 수열 : F(0) = 0, F(1) = 1
// 기저 상태 파악 후 미리 배열 등에 저장
// 
// 6. 구현하기
// i) Bottom - Up
// - 반복문 사용
// - tabulation
/*
void fibo() {
	dp[0] = 0;
	dp[1] = 1;
	
	for (int i = 2; i <= 90; i++) {
		dp[i] = dp[i - 1] + dp[i - 2];
	}
}
*/
// ii) Top - Down
// - 재귀 사용
// - memoization
/*
ll fibo (int n) {
	if (n == 0 || n == 1) {
		return dp[n] = n;
	}

	if (dp[n] == 0) {
		dp[n] = fibo(n - 1) + fibo(n - 2);
	}

	return dp[n];
}
*/

// 문제 해결 과정 - 구현 방법
// Bottom - Up (반복문 사용)
// 아래에서부터 계산을 수행하고 누적시켜서 전체 큰 문제를 해결하는 방식
// 기저 상태 : dp[0] -> 목표 상태 : dp[n]
// - 피보나치 수열 : dp[0], dp[1] -> dp[n]
// Tabulation
// - table-filling
// - table에 저장된 값에 직접 접근하여 재활용
// * dp[0], dp[1] -> dp[5]
// * 함수를 재귀 호출하지 않아 시간 & 메모리를 절약할 수 있어 !
// 
// Top - Down (재귀 사용)
// 위에서부터 바로 호출 시작,
// 기저 상태까지 내려간 다음 결과값을 재귀를 통해 전이시켜 재활용
// f(n) 값을 찾기 위해 dp[0] 상태까지 내려감
// - 피보나치 수열 : f(n) -> f(n - 1), f(n - 2) -> ... -> f(1), f(0)
// Memoization
// - 이전에 계산을 완료한 상태값을 메모해둠
// * F(5) -> F(0), F(1)
// * 점화식을 한 눈에 볼 수 있어 !

// 문제 해결 과정
// 1. DP로 풀 수 있는 문제인지 점검
// 2. 문제의 변수 파악
// 3. 변수 간 관계식 만들기 (점화식)
// 4. 메모하기
// 5. 기저 상태 파악하기
// 6. 구현하기 (Bottom - Up, Top - Down)
// 특정한 경우에 사용하는 알고리즘이 아니라
// 하나의 방법론이므로 다양한 문제 해결에 사용 가능

// 동적 계획법 - 중간 점검
// 동적 계획법 (Dynamic Programming)
// 1. 큰 문제를 작은 문제로 쪼개어
// 2. 그 답을 저장해두고 재활용
// 사용 조건
// 1. 최적 부분 구조
// - 부분 문제의 최적 결과값 -> 전체 문제의 최적 결과
// 2. 중복되는 부분 문제
// - 동일한 작은 문제들이 반복하여 나타남

// 문제 해결 연습
// 1. DP 가능?
// 2. 변수
// 3. 점화식
// 4. 메모
// 5. 기저 상태
// 6. 구현 (Bottom - Up, Top - Down)

// 문제 해결 연습
// 문제 풀이 tip
// 1. 완전탐색, 백트래킹 등의 아이디어로 문제를 해결할 수 있는지 확인
// 2. 일단 재귀함수로 완전탐색 프로그램 작성 (Top - down)
// -> 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있는지 살펴보자
// (중복되는 부분 문제)
// -> 가능하다고 판단되면 memoization 기법을 이용해 코드 개선
// 모듈로 연산 (%)
// (a + b) % m = ((a % m) + (b % m)) % m
// (+, -, *에 대해 모두 성립)
// - 모듈로 산술 연산에 분배법칙 성립 !
// - 점화식을 사용할 때마다 모듈로 연산(%)을 해주자
// - f(n) = (f(n - 1) + f(n - 2)) % m
//		  = (f(n - 1) % m + (f(n - 2) % m)) % m

// 문제 유형
// 1. LIS
// - Longest Increasing Subsequence
// - 가장 긴 증가하는 부분 수열
// 2. LCS
// - Longest Common Subsequence
// - 가장 긴 공통 부분 수열
// 3. knapsack
// - 배낭 문제

// 문제 유형 - LIS
// 가장 긴 증가하는 부분 수열
// (Longest Increasing Subsequence)
// - 부분 수열 : 어떠한 수열에서 일부 원소를 뽑아내어 새로 만든 수열
// -> 그 중에서 가장 길면서 오름차순을 유지하는 수열
// -> 반드시 하나로 결정되지 X

// 문제 유형 - LCS
// 가장 긴 공통 부분 수열
// (Longest Common Subsequence)
// - 변수 : 두 문자열의 인덱스 i, j
// - dp[i][j] : s1[0 ... i]와 s2[0 ... j]의 LCS 길이
// - 기저상태 : dp[0][0] = 0
// - 점화식



// 피보나치 비스무리한 수열은 f(n) = f(n-1) + f(n-3)인 수열이다.
long fibo(int n) {
	long dp[116] = { 0 };

	// f(1) = f(2) = f(3) = 1
	dp[0] = 1;
	dp[1] = 1;
	dp[2] = 1;
	
	for (int i = 3; i < 116; i++) {
		dp[i] = dp[i - 1] + dp[i - 3];
	}

	return dp[n];
}

int main() {
	int n;

	// 자연수 n(1 ≤ n ≤ 116)이 주어진다.
	cin >> n;

	// n번째 피보나치 비스무리한 수를 출력한다.
	cout << fibo(n - 1);

	return 0;
}